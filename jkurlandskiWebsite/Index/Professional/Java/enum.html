<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Enums</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="../../default.css" rel="stylesheet" type="text/css" media="all" />
<link href="../../fonts.css" rel="stylesheet" type="text/css" media="all" />
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->
</head>
<body>
<div id="wrapper">
	<div id="header-wrapper">
		<div id="menu" class="container">
			<ul>
				<li><a href="../index.html">Home</a></li>
				<li><a href="../Guava/index.html">Guava</a></li>
				<li class="current_page_item"><a href="../Java/index.html">Java</a></li>
				<li><a href="../NLP_AI/index.html">NLP / AIL</a></li>
				<li><a href="../CSS_HTML/index.html">CSS / HTML</a></li>
				<li><a href="../Web/index.html">Web</a></li>
			</ul>
		</div>
		<!-- end #menu -->
		<div id="header" class="container">
			<div id="logo">
				<h1>Close to the</h1>
				<h1>Machine</h1>
				<p></p>
				<p>Jerry Kurlandski</p>
			</div>
			<div id="header-image1"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
			<div id="header-image2"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
		</div>
	</div>
	<div id="page" class="container">
		<div id="content">
			<div class="title">
				<h2>Java Enums</h2>
			</div>
			<p>This page is focused on the <i>syntax</i> of enums. Apart from the short introduction below, here we do not delve into when you should use the enum type, and we do not at all consider its advantages over regular classes. For the latter, see Chapter 6 of <i>Effective Java</i>, Joshua Bloch's Java-programming bible.</p>
			<p>I find that the enum type is one of the most useful tools modern programming languages have to offer. Whenever you find yourself creating a class which has a limited number of pre-defined instances, you should ask yourself whether an enum wouldn't be a better implementation. For instance, in the first listing below I show an enum for parts of speech--noun, verb, adjective and so on. Since there are a small number of pre-defined types of this class, it is a perfect candidate for an enum. In fact, any non-enum implementation would throw off red warning flags in my head, and in my opinion would need to be justified.</p>
			<p>Here's Listing 1, showing the simplest usage of an enum, in this case serving mainly as a way of implementing a pre-determined set of related objects.</p>
			
<p class="precaption">Listing 1: Creating a simple enum</p>
<pre class="preCodeWithCaption">
public enum PartOfSpeech {
    NOUN, VERB, ADJECTIVE, ADVERB, PREPOSITION, DETERMINER
}
</pre>

            <p>But enums can serve as more than just a list of subtypes. An enum can be a proper class in Java, with fields. In another part of this web site I discuss ConceptNet, a database of world knowledge, and I offer some basic code that can be used to retrieve information from this online resource. In the code which I provide there I have a Relation enum. Here is an abbreviated version of the Relation type, to serve as an example of an enum implementation more complicated than the basic one given in Listing 1.</p>
<p class="precaption">Listing 2: An enum with instance fields</p>
<pre class="preCodeWithCaption">
public enum Relation {Antonym(&quot;is the opposite of&quot;), AtLocation(&quot;is at&quot;),  
    CapableOf(&quot;is capable of&quot;), Causes(&quot;causes&quot;), PartOf(&quot;is part of&quot;),  
    RelatedTo(&quot;is related to&quot;), UsedFor(&quot;is used for&quot;);

    private String gloss;

    Relation(String str)   {
        gloss = str;
    }
    
    @Override
    public String toString()    {
        return gloss;
    }
}
</pre>

        <p>In the curly braces following the enum keyword and the name of the enum, you see seven types of Relations, each one associated with a string. We'll get to the string in a moment, but first I want to discuss the use of "Pascal case" in the names of the Relation types. Traditionally in Java instances of enums are put into all-uppercase, as I did for the parts of speech in Listing 1. However, there are times when I think readability prefers "Pascal case," that is, starting with a capital letter and using mixed case to signal separate words in the name. Had I adhered to the uppercase naming convention for enums, in Listing 2 I would have had to assign the AtLocation type either the name ATLOCATION or AT_LOCATION--both of which are an eyesore, in my humble opinion.</p>
        <p>Moving on to other aspects of Listing 2, we see that the Relation enum is looks like a class. It even has a constructor method bearing the Relation name--just like a class. As a matter of fact, in Java enums really are classes--a special kind of class that provides a singleton object for each enum type. In other words, every Relation.AtLocation reference points to exactly the same object. In Listing 2 we see that each type has a field called <code>gloss</code>, which "translates" the meaning of the relation into natural-sounding English. Because it's a singleton, every Relation.PartOf reference has exactly the same gloss.</p>
        <p>You can write getters for the fields of an enum; and I could have done so for my Relation class. I chose to override the Object toString( ) method, and have that return the gloss instead. See the next listing, which demonstrates the use of our overridden toString( ) method using a unit test.</p>

<p class="precaption">Listing 3: Using name( ) and other enum methods</p>
<pre class="preCodeWithCaption">
@Test
public void testToString() {
    Relation atLocation = Relation.AtLocation;      
    assertEquals("is at", atLocation.toString());
}
</pre>

        <p>Every enum comes with a name( ) method, which you can use when you need the actual name of your enum type.</p>

<p class="precaption">Listing 4: Using an enum's name( ) method</p>
<pre class="preCodeWithCaption">
@Test
public void testName() {
    Relation atLocation = Relation.AtLocation;  
    assertEquals("AtLocation", atLocation.name());
}
</pre>

        <p>Another enum method is valueOf( ), which allows you to recognize a String as the name of a particular enum instance. This method throws an IllegalArgumentException if the match fails, so you should always figure out how you want to handle that case. The next listing provides two examples, one in which the match will succeed, the other in which it will fail.</p>

<p class="precaption">Listing 5: Using valueOf( ) to decide if a string matches an enum type</p>
<pre class="preCodeWithCaption">
@Test
public void testValueOfMatch() {
    try {
        Relation relation = Relation.valueOf("AtLocation");     
        assertEquals(Relation.AtLocation, relation);
    } catch (IllegalArgumentException e) {
        System.out.println("Not a recognized Relation type.");
    }
}

@Test
public void testValueOfNoMatch() {
    try {
        Relation.valueOf("KnownAs");    
        // Note: Instead of failing the test here, consider using 
        // @Test(expected=IllegalArgumentException.class)
        fail();
    } catch (IllegalArgumentException e) {
        System.out.println("Not a recognized Relation type.");
        assertTrue(true);
    }
}
</pre>

        <p>As the comment in the second unit test points out, there are better ways of verifying that a unit test will throw a particular exception. I discuss them under unit testing--you'll find a link in the sidebar.</p>
        <p>Often it is inconvenient to wrap every call to valueOf( ) with a try-and-catch. I therefore frequently implement a method that tells me in advance whether my string is in fact a known enum instance. Here's how you might implement that method for Relation.</p>

<p class="precaption">Listing 6: A method that tells you whether a string is a known type of Relation</p>
<pre class="preCodeWithCaption">
// Note that this method is case-sensitive.
public static boolean isRelation(String input)    {
    try {
        Relation.valueOf(input);
    } catch (IllegalArgumentException e) {
        // The relation isn't in our enum.
        return false;
    }
    return true;
}
</pre>
        <p>Alternately, you might instead implement a <code>public Relation getRelation(String)</code> method that returns a valid Relation instance if valueOf( ) succeeds, or null if it fails. But in this case you have to make sure you remember to check for null--few things are uglier than a runtime NullPointerException.</p>

		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
				<div class="title">
					<h2>Internal Java Links</h2>
				</div>
				<ul class="style2">
					<li><a href="mapSort.html">Sorting on a Map key</a></li>
				</ul>
			</div>
		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
				<div class="title">
					<h2>External Guava Links</h2>
				</div>
				<ul class="style2">
				</ul>
			</div>
		</div>
	</div>
</div>
<div id="copyright" class="container">
	<p>Copyright (c) 2013 jkurlandski.com. All rights reserved. | Original design by <a href="http://www.freecsstemplates.org/" rel="nofollow">FreeCSSTemplates.org</a>.</p>
</div>
</body>
</html>
