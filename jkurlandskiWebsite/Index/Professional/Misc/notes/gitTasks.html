<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Git Tasks</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="../../../default.css" rel="stylesheet" type="text/css" media="all" />
<link href="../../../fonts.css" rel="stylesheet" type="text/css" media="all" />
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->
</head>
<body>
<div id="wrapper">
	<div id="header-wrapper">
		<div id="menu" class="container">
			<ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../Java/index.html">Java</a></li>
                <li><a href="../Guava/index.html">Guava</a></li>
                <li><a href="../CSS_HTML/index.html">CSS / HTML</a></li>
                <li><a href="../Web/index.html">Web</a></li>
                <li class="current_page_item"><a href="../Misc/index.html">Miscellaneous</a></li>
                <li><a href="../professionalContact.html">Contact</a></li>
			</ul>
		</div>
		<!-- end #menu -->
		<div id="header" class="container">
			<div id="logo">
				<h1>Close to the</h1>
				<h1>Machine</h1>
				<p>Jerry Kurlandski</p>
			</div>
            <div id="header-image1"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
            <div id="header-image2"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
		</div>
	</div>
	<div id="page" class="container">
		<div id="content">
			<div class="title">
				<h2>Git Tasks</h2>
			</div>
            <p>This page shows you how to link individual Git commands together in order to accomplish a particular task or set of tasks.</p>

            <h3>Task</h3>
            <h4>&bull; Template</h4>
            <br/>
			
            <p> </p>
            
<pre class="preCode">

</pre>
			
    		<p> </p>
				
            <h3>Task</h3>
            <h4>&bull; </h4>
            <br/>
            
            <p> </p>
            
<pre class="preCode">

</pre>
            
            <p> </p>
                
            <h3>Task</h3>
            <h4>&bull; Download an existing git repository so that you can begin making changes to the code.</h4>
            <br/>
            
            <p>Downloading an existing git repository is called "cloning" the repository. It's called "cloning" because of the way git works--you actually keep a local copy of that repository, and commit your local changes there. (This is unlike other version control systems, which are centralized rather than distributed.)</p>
            <p>The first step in this task is getting a URL for the existing git repository. Once you have that, you can follow the example below.</p>
            
<pre class="preCode">
$ git clone https://github.com/someProject/SomeProject.git
Cloning into 'SomeProject'...
remote: Counting objects: 181, done.
remote: Compressing objects: 100% (134/134), done.
remote: Total 181 (delta 23), reused 179 (delta 21), pack-reused 0
Receiving objects: 100% (181/181), 136.50 KiB | 0 bytes/s, done.
Resolving deltas: 100% (23/23), done.
Checking connectivity... done.

$ cd SomeProject

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

nothing to commit, working directory clean

</pre>
            
            <p>Once the clone has finished, you cd into the subdirectory for the project you just created. The "git status" command can be used to reassure yourself that all has gone well.</p>
                
            <h3>Task</h3>
            <h4>&bull; Check the status of your working branch.</h4>
            <h4>&bull; Stage a newly-updated file.</h4>
            <br/>
            <p>JERRY: finish this</p>
            <p>Use "git status" to see where things stand&mdash;what you've changed, what you've staged, what's ready to be committed.</p>
            
<pre class="preCode">
$ git status
On branch newMatch
Your branch is ahead of 'origin/newMatch' by 2 commits.
  (use "git push" to publish your local commits)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   src/test/java/ipgraph/matching/MatchingTest.java

no changes added to commit (use "git add" and/or "git commit -a")

</pre>
            
            <p>The call to "git status" has returned a lot of information. The line "On branch newMatch" tells me which local branch I'm working with. (More on branches, below.) The next two lines tell me that I have already committed some changes to my local repository, but they have not been pushed to the repository on the network&mdash;the one I share with other developers. The lines beneath the heading "Changes not staged for commit:" are the ones I'm most interested in: this information is saying that I have made some changes which are not staged. Something is "staged" when it is ready to be committed; if I do a commit, then only those items which are staged will be committed. The last line of the output tells me what I need to do to stage these changes.</p>

<pre class="preCode">
$ git add src/test/java/ipgraph/matching/MatchingTest.java

$ git status
On branch newMatch
Your branch is ahead of 'origin/newMatch' by 2 commits.
  (use "git push" to publish your local commits)

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   src/test/java/ipgraph/matching/MatchingTest.java
</pre>
		<p>Compare this output to the output above. Now everything which has been changed is staged. The next time I commit, my changes to MatchingTest.java will be part of that commit.</p>
                
            <h3>Task</h3>
            <h4>&bull; Stage newly-added files collectively.</h4>
            <h4>&bull; Commit these newly-added files collectively.</h4>
            <br/>
			
 		   <p>When you stage a change, you are basically saying "This change is ready to be committed." It doesn't actually do the commit, though. In this scenario, you have created two new files in the project, and you want git to start tracking them.</p>
 		  <p>First we do a status check.</p>
             
<pre class="preCode">
$ git status
On branch newAlgorithm
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   src/main/java/com/myPackage/CompareGraphs.java
	new file:   src/main/java/com/myPackage/CompareGraphsTest.java

Changes not staged for commit:
  (use "git add &lt;file&gt;...&quot; to update what will be committed)
  (use "git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   src/main/java/com/myPackage/CompareGraphs.java
	modified:   src/main/java/com/myPackage/CompareGraphsTest.java
</pre>
			
    		<p>We could add these two new files for tracking individually. This is what you would do if you want to add only some of the files listed. But in this case we want to add all the files that the "git status" lists, so we'll do it in one step. Then we'll do another "git status" to check the result.</p>
				
<pre class="preCode">
$ git add --all

$ git status
On branch newAlgorithm
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	new file:   src/main/java/com/myPackage/CompareGraphs.java
	new file:   src/main/java/com/myPackage/CompareGraphsTest.java
</pre>
			
    		<p>Now we can commit.</p>
				
<pre class="preCode">
$ git commit -m "Added new files."
[newAlgorithm d55f997] Added new files.
 2 files changed, 1695 insertions(+)
 create mode 100755 src/main/java/com/myPackage/CompareGraphs.java
 create mode 100644 src/main/java/com/myPackage/CompareGraphsTest.java

$ git status
On branch newMatch
nothing to commit, working directory clean
</pre>


<pre class="preCode">
</pre>
			
    		<p> </p>
				
            <h3>Task</h3>
            <h4>&bull; Push local commits to the shared repository.</h4>
            <br/>
			
            <p>In this scenario, you've made a number of changes to your local copy of a shared repository. Now you want other developers to see your work.</p>
            
<pre class="preCode">
$ git status
On branch newAlgorithm
Your branch is ahead of 'origin/newAlgorithm' by 3 commits.
  (use "git push" to publish your local commits)

nothing to commit, working directory clean

$ git push
warning: push.default is unset; its implicit value is changing in
Git 2.0 from 'matching' to 'simple'. To squelch this message
and maintain the current behavior after the default changes, use:

  git config --global push.default matching

To squelch this message and adopt the new behavior now, use:

  git config --global push.default simple

When push.default is set to 'matching', git will push local branches
to the remote branches that already exist with the same name.

In Git 2.0, Git will default to the more conservative 'simple'
behavior, which only pushes the current branch to the corresponding
remote branch that 'git pull' uses to update the current branch.

See 'git help config' and search for 'push.default' for further information.
(the 'simple' mode was introduced in Git 1.7.11. Use the similar mode
'current' instead of 'simple' if you sometimes use older versions of Git)

Counting objects: 105, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (43/43), done.
Writing objects: 100% (61/61), 8.12 KiB | 0 bytes/s, done.
Total 61 (delta 18), reused 0 (delta 0)
To https://github.com/someRepo/someRepo.git
   11a7bd9..dfc657e  newAlgorithm -> newAlgorithm

$ git status
On branch newAlgorithm
Your branch is up-to-date with 'origin/newAlgorithm'.

nothing to commit, working directory clean
</pre>
			
    		<p>Our status check shows how much our local version of the repository is out-of-synch with the one shared by all developers. The call to "git push" first results in a long warning preparing us for some upcoming changes to the Git application itself&mdash;we can choose to ignore them, taking no action. Then "git push" does the job of synchronizing our local branches with the remote repository which everyone shares. Then another call to "git status" tells us everything is up-to-date.</p>
				
            <h3>Task</h3>
            <h4>&bull; Push local commits to on a particular branch to the shared repository.</h4>
            <br/>
			
            <p>Similar to the above scenario, but in this case we've modified and committed to a local branch, and we want only changes to that branch to be pushed.</p>
            
<pre class="preCode">
$ git status
On branch stanford_parser_rte_sf
Your branch is ahead of 'origin/stanford_parser_rte_sf' by 3 commits.
  (use "git push" to publish your local commits)
  
nothing to commit, working directory clean

$ git push origin stanford_parser_rte_sf
Counting objects: 106, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (28/28), done.
Writing objects: 100% (49/49), 4.40 KiB | 0 bytes/s, done.
Total 49 (delta 11), reused 0 (delta 0)
To git@git.ipsoft.com:amelia.git
   b5ca8ea..030afea  stanford_parser_rte_sf -> stanford_parser_rte_sf
   
$ git status
On branch stanford_parser_rte_sf
Your branch is up-to-date with 'origin/stanford_parser_rte_sf'.
</pre>
			
				
            <h3>Task</h3>
            <h4>&bull; View the files being tracked by the repository</h4>
            <h4>&bull; Stop a file from being tracked by the repository, but don't remove it from the file system</h4>
            <h4>&bull; Add the file name to the global repository ignore list</h4>
            <br/>
			
            <p>I work on a Mac, where each directory has a "hidden" .DS_Store file. The problem is, sometimes I end up creating a repository before I've remembered to have these files ignored.</p>
            
            <p>First let's see which files are being tracked by git, using "git ls-files".</p>
            
<pre class="preCode">
$ git ls-files
.DS_Store
src/main/java/.DS_Store
src/main/java/com/.DS_Store
src/main/java/com/interdataworking/.DS_Store
src/main/java/com/interdataworking/UntypedGateway.class
src/main/java/com/interdataworking/UntypedGateway.java
(...)

</pre>
			
    		<p>As you can see, there are three file types listed here, and it turns out I want my repository to store only the .java files.</p>
				
<pre class="preCode">
$ git rm --cached .DS_Store
rm '.DS_Store'

$ git ls-files
src/main/java/.DS_Store
src/main/java/com/.DS_Store
src/main/java/com/interdataworking/.DS_Store
src/main/java/com/interdataworking/UntypedGateway.class
src/main/java/com/interdataworking/UntypedGateway.java
(...)
</pre>
			
    		<p>The "git rm --cached" command worked, but it looks as though it is useful only for a single file.</p>
    		<p>The next line, a mix of shell commands and git commands, will perform a "git rm" recursively, that is, on all the files whose names are .DS_Store.</p>
    		<p>The I use the same approach to remove from the repository all files whose names end in ".class".</p>
				
<pre class="preCode">
$ find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch
rm 'src/main/java/.DS_Store'
rm 'src/main/java/com/.DS_Store'
rm 'src/main/java/com/interdataworking/.DS_Store'

$ git ls-files
src/main/java/com/interdataworking/UntypedGateway.class
src/main/java/com/interdataworking/UntypedGateway.java
(...)

$ find . -name *.class -print0 | xargs -0 git rm -f --ignore-unmatch
rm 'src/main/java/com/interdataworking/UntypedGateway.class'
(...)

$ git ls-files
src/main/java/com/interdataworking/UntypedGateway.java
(...)

</pre>
			
    		<p>Whew! So finally the unwanted .class and .DS_Store files are untracked. Now let's make sure git permanently ignores them.</p>
<pre class="preCode">
$ touch .gitignore

$ vim .gitignore
(Edit this file so that it has two lines, with &quot;.class&quot; on the first and .DS_Store on the second.)

$ cat .gitignore
.class
.DS_Store

$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;...&quot; to unstage)

	deleted:    .DS_Store
	deleted:    src/main/java/.DS_Store
	deleted:    src/main/java/com/.DS_Store
	deleted:    src/main/java/com/interdataworking/.DS_Store
	deleted:    src/main/java/com/interdataworking/UntypedGateway.class
(...)

Untracked files:
  (use "git add &lt;file&gt;...&quot; to include in what will be committed)

	.gitignore

</pre>
			
    		<p>The status check shows that we still have to add the .gitignore file, and then commit all of our changes.</p>
<pre class="preCode">
$ git add .gitignore

$ git commit -m "Deleting unwanted files from repo. Creating .gitignore."
[master b2d6f98] Deleting unwanted files from repo. Creating .gitignore.
 126 files changed, 2 insertions(+)
 delete mode 100644 .DS_Store
 create mode 100644 .gitignore
 delete mode 100644 src/main/java/.DS_Store
 delete mode 100644 src/main/java/com/.DS_Store
 delete mode 100644 src/main/java/com/interdataworking/.DS_Store
(...)

$ git status
On branch master
nothing to commit, working directory clean

$ git ls-files
.gitignore
src/main/java/com/interdataworking/UntypedGateway.java
(...)
</pre>
			
    		<p>We committed our changes, used "git status" to verify that everything has been committed, then finally used "git ls-files" to make sure that we are tracking only .java files. Fini.</p>
		
			
			
            <h3>Task</h3>
            <h4>&bull; Create a new repository in a directory, and add to the repository all the files in this directory.</h4>
            <br/>
<p>JERRY: do this without including the unwanted .DS_Store and .class files.</p>			
            <p>Suppose there's some open source code you want to have a look at, and suppose that, while having a look at it you see some things you'd like to change. I've done that, and then I've been very annoyed with myself for having no easy way, at some later time, to see the changes I've made.</p>
            <p>The smart thing to do is to put the original version of the code into a repository. It's a simple three-step process, though I've added a few status-checks so that we can see what's happening.</p>
            
<pre class="preCode">
$ ls
src

~/workspace/SimilarityFlooding$ git init
Initialized empty Git repository in /Users/geraldkurlandski/workspace/SimilarityFlooding/.git/
~/workspace/SimilarityFlooding$ git status
On branch master

Initial commit

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

	src/

nothing added to commit but untracked files present (use "git add"
~/workspace/SimilarityFlooding$ git add .

~/workspace/SimilarityFlooding$ git status
On branch master

Initial commit

Changes to be committed:
  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)

	new file:   src/main/java/.DS_Store
	new file:   src/main/java/com/.DS_Store
	new file:   src/main/java/com/interdataworking/.DS_Store
	new file:   src/main/java/com/interdataworking/UntypedGateway.class
	new file:   src/main/java/com/interdataworking/UntypedGateway.java
	new file:   src/main/java/com/interdataworking/mm/.DS_Store
	new file:   src/main/java/com/interdataworking/mm/MapVocabulary.class
	new file:   src/main/java/com/interdataworking/mm/MapVocabulary.java
	new file:   src/main/java/com/interdataworking/mm/alg/FilterBest.class
	(...)
	new file:   src/main/java/org/xml/sax/helpers/LocatorImpl.java
	new file:   src/main/java/org/xml/sax/helpers/ParserFactory.class
	new file:   src/main/java/org/xml/sax/helpers/ParserFactory.java

$ git commit -m &quot;Started version control.&quot;
[master (root-commit) f501fec] Started version control.
 213 files changed, 19442 insertions(+)

$ git status
On branch master
nothing to commit, working directory clean
</pre>
			
    		<p>The three key commands are "git init", "git add .", and "git commit". Now you can make all the changes you want and not only do you have a record of each and every one, but you also have the ability to roll things back to a previous version.</p>
				
            <h3>Task</h3>
            <h4>&bull; View local branches as well as local copies of remote branches.</h4>

            <br/>
            <p>Use "git branch" to view all local branches. Use "git branch -r" to view local copies of all remote branches.</p>
            
<pre class="preCode">
$ git branch
  event-priority
* master
  stanford_parser

$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/testing
  origin/master

</pre>
            
            <p>With "git branch", the asterisk indicates the current branch.</p>
                
            <h3>Task</h3>
            <h4>&bull; Compare two local branches, viewing the differences at only the directory-level.</h4>
            <br/>
			
            <p>"git diff" will ordinarily show you the diffs of two branches at a fine-grained level, for example, the line-by-line differences between two files. But you can use the "--name-status" argument to see only file differences.</p>
			<p>JERRY: get an example that also has modified files</p>
            
<pre class="preCode">
$ git branch
* graphMatching
  master

$ git diff graphMatching master --name-status
D       app-distribution/deployments//problemClassifier/features.tsv
D       app-distribution/deployments//problemClassifier/model
</pre>
			
    		<p> </p>
				
            <h3>Task</h3>
            <h4>&bull; Compare a local branch to a remote branch, viewing the differences at only the directory-level.</h4>
            <br/>
			
            <p>"git diff" will ordinarily show you the diffs of two branches at a fine-grained level, for example, the line-by-line differences between two files. But you can use the "--name-status" argument to see only file differences.</p>
			<p>JERRY: get an example that also has modified files; modify above so it doesn't repeat the preceding task</p>
            
<pre class="preCode">
$ git branch
  master
* newMatch

$ git branch -r
  origin/HEAD -> origin/master
  origin/master
  origin/newMatch
  
$ git diff newMatch origin/newMatch --name-status
D       src/test/java/ipgraph/matching/AmeliaEarhartTest.java
D       src/test/resources/AmeliaEarhart.txt
D       src/test/resources/AmeliaEarhartTest.json
</pre>
			
    		<p> </p>
				
            <h3>Task</h3>
            <h4>&bull; Retrieve recent changes from the remote repository.</h4>
            <h4>&bull; Let these changes be automatically merged into your local version of the remote repository.</h4>

            <br/>
            <p>Because of its simplicity, you will probably want to make this command part of your regular workflow.</p>
			<p>By default, "git pull" fetches all branches from the remote repository. This may sound like a waste of hard disk space, but the overhead is fairly small.</p>
            
<pre class="preCode">
$ git branch
* master

$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/semantics
  origin/master
  
$ git pull
remote: Counting objects: 3310, done.
remote: Compressing objects: 100% (1499/1499), done.
remote: Total 2767 (delta 1221), reused 1508 (delta 522)
Receiving objects: 100% (2767/2767), 645.13 KiB | 0 bytes/s, done.
Resolving deltas: 100% (1221/1221), completed with 192 local objects.
From git.ipsoft.com:amelia
  bd300cd..78d4dd8  master     -&gt; origin/master
 * [new branch]      tfidf-improvements -&gt; origin/tfidf-improvements
Updating bd300cd..78d4dd8
Fast-forward
  f122a36..1d40b90  semantics  -&gt; origin/semantics


$ git branch
* master

$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/semantics
  origin/master
  origin/merge-tfidf-improvements
 
</pre>
		<br/>
		<p>In the steps above, first we have a look at both local branches and local versions of remote branches. Then we do the pull, which: (1) updates the local master branch, merging remote changes in; (2) gets a new branch called tfidf-improvements; and (3) updates a second local branch called semantics, merging the changes into that branch as well.</p>

<pre class="preCode">
</pre>


            <h3>Task</h3>
            <h4>&bull; Retrieve remote changes only from the master branch of the remote repository.</h4>
            <h4>&bull; Merge these changes into your local master branch after checking the differences.</h4>

            <br/>
            <p>Use this version of "git fetch" to retrieve only the master branch from your origin branch. (Like "git pull", "git fetch" fetches all branches from a remote repository by default.)</p>
            
<pre class="preCode">
$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/testing
  origin/master

$ git fetch origin master:remotes/origin/master
remote: Counting objects: 16286, done.
remote: Compressing objects: 100% (7005/7005), done.
remote: Total 15278 (delta 6807), reused 11158 (delta 4411)
Receiving objects: 100% (15278/15278), 339.89 MiB | 23.69 MiB/s, done.
Resolving deltas: 100% (6807/6807), completed with 418 local objects.
From git.repo.com:xxx
   2a0e457..bd300cd  master     -&gt; origin/master
   
$ git diff master remotes/origin/master
(...)
</pre>
		<br/>
		<p>Now that we've had a look at the diffs, we're ready to merge these changes into our local master branch. Then we'll do another diff to make sure the merge worked.</p>

<pre class="preCode">
$ git merge remotes/origin/master
create mode (...)
delete mode (...)

$ git diff master remotes/origin/master
$
</pre>

            <h3>Task</h3>
            <h4>&bull; Create a new branch from the master branch.</h4>
            <h4>&bull; Switch to the new branch.</h4>

            <br/>
            <p>Use "git branch &lt;new branch name&gt;" to create a new branch from the master branch. Use "git checkout &lt;new branch name&gt;" to switch to another branch.</p>
            
<pre class="preCode">
$ git branch
* master

$ git branch new

$ git checkout new
Switched to branch 'new'

$ git branch
  master
* new
</pre>

            <h3>Task</h3>
            <h4>&bull; Check the status of local branches.</h4>
            <h4>&bull; Delete those which are merged as well as not merged into the current branch.</h4>

            <br/>
            <p>When you have several local branches, some may be merged into the current branch, and some may not be. In this task, we want to delete both kinds.</p>
            
<pre class="preCode">
$ git branch --merged
* master
  event-priority

$ git branch --no-merged
  stanford_parser
  
$ git branch -d event-priority
Deleted branch event-priority (was 10cd4d3).  

$ git branch -D stanford_parser
Deleted branch stanford_parser (was fa047e9).
</pre>
			
			
            

		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
                <div class="title">
                    <h2>Internal Miscellaneous Links</h2>
                </div>
                <ul class="style2">
                    <li><a href="commandLine.html">A Few Command Line Tricks</a></li>
                    <li><a href="macNotes.html">Mac Notes</a></li>
                    <li><a href="svnCommands.html">SVN Command Summary</a></li>
                    <li><a href="svnTasks.html">SVN Tasks</a></li>
                    <li><a href="subversion-cheat-sheet-v1.pdf">SVN Cheat Sheet by AddedBytes.com</a></li>
                </ul>
			</div>
		</div>
	</div>
</div>
<div id="copyright" class="container">
	<p>&copy; 2013-2015 Jerry Kurlandski. All rights reserved. | Original design by <a href="http://www.freecsstemplates.org/" rel="nofollow">FreeCSSTemplates.org</a>.</p>
</div>
</body>
</html>
