<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>$ help</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="../../default.css" rel="stylesheet" type="text/css" media="all" />
<link href="../../fonts.css" rel="stylesheet" type="text/css" media="all" />
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->
</head>
<body>
<div id="wrapper">
	<div id="header-wrapper">
		<div id="menu" class="container">
			<ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../Java/index.html">Java</a></li>
                <li><a href="../Guava/index.html">Guava</a></li>
                <li><a href="../CSS_HTML/index.html">CSS / HTML</a></li>
                <li><a href="../Web/index.html">Web</a></li>
                <li class="current_page_item"><a href="../Misc/index.html">Miscellaneous</a></li>
                <li><a href="../professionalContact.html">Contact</a></li>
			</ul>
		</div>
		<!-- end #menu -->
		<div id="header" class="container">
			<div id="logo">
				<h1>Close to the</h1>
				<h1>Machine</h1>
				<p>Jerry Kurlandski</p>
			</div>
            <div id="header-image1"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
            <div id="header-image2"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
		</div>
	</div>
	<div id="page" class="container">
		<div id="content">
			<div class="title">
				<h2>A Few Command Line Tricks</h2>
			</div>
            <br/>
            
            <p>Here's a page where I keep a couple of shell commands, for the next time I need them. The one-liners are first; the longer shell scripts after that.</p>
			
            <h3>On the Mac</h3>          
            <p>Every once in a while you run into a Unix command that doesn't quite work on the Mac. You'll find notes on these exceptions <a href="macNotes.html">on this page</a>.</p>

			<h3>One-Liners</h3>
			<br/>
            
            <div class="singleSpacedDescription">
                <h4>perl -nle 'my @vals = $_ =~ / 212.* /g; print "@vals"' data.txt</h4>
                <p>Read the file data.txt and output every string that starts with "212" preceded by a space character, ending with the first space character which follows the number. Output goes to stdout.</p>
            </div>
                        
            <div class="singleSpacedDescription">
                <h4>perl -p -e 's/\t/\n/g' data.txt</h4>
                <p>Replace tab with newline in the file data.txt. Output goes to stdout.</p>
            </div>
                        
            <div class="singleSpacedDescription">
                <h4>perl -pi -e 's/\t/\n/g' data.txt</h4>
                <p>Replace tab with newline in the file data.txt. The file itself is changed.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>find . -size 0 -ls 2>/dev/null</h4>
                <h4>find . -empty -ls 2&gt;/dev/null</h4>
                <p>Two ways to find all empty files in the current directory, recursively down the tree. The "-ls" argument lists the file properties in detail; remove it to display just the file names.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>find . -not -empty -ls 2>/dev/null</h4>
                <p>Find all non-empty files in the current directory, recursively down the tree.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>find . -maxdepth 1 -empty -ls 2>/dev/null</h4>
                <p>Find all empty files in the current directory, non-recursively&mdash;i.e., in the current directory only.</p>
            </div>
            
             <div class="singleSpacedDescription">
                <h4>find . -size  0 -print0 | xargs -0 rm</h4>
                <p>Find and delete all non-empty files in the current directory, recursively down the tree.</p>
            </div>
            
           <div class="singleSpacedDescription">
                <h4>find . -name "*txt" 2&gt;/dev/null</h4>
                <p>Find all the txt files in the current directory, recursively down the tree.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>find . -name "*txt" 2&gt;/dev/null | wc -l</h4>
                <p>Get a count of all the txt files in the current directory, recursively down the tree.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>find . -type f | wc -l</h4>
                <h4>find -maxdepth 1 -type d | while read -r dir; do printf "%s:\t" "$dir"; find "$dir" -type f | wc -l; done</h4>
                <p>Both of these will give you a count of all the files in the current directory, recursively down the tree.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>ls -d t*</h4>
                <p>Non-recursive "ls" of all directory contents starting with "t". (Without -d you also get the contents of the items if they are directories.)</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>ls -1</h4>
                <p>Perform an "ls" on this directory, displaying each item on a separate line. (That's the digit "1" after the minus sign, not the letter "l".)</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>cut -c1-3 data.txt</h4>
                <p>Extract the first through third column of each line of the file data.txt.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>cut -c3- data.txt</h4>
                <p>Extract from the third character to the end of the line for each line of data.txt.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>cut -d' ' -f2 data.txt</h4>
                <p>Extract the second field, where space is the delimiter, of data.txt.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>unzip -qq -t &lt;jarfile&gt;</h4>
                <p>Check whether a jar file is corrupt. If nothing appears, the jar file is NOT corrupt.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>Ctrl-a</h4>
                <p>Go to the start of the command at the current command line.</p>
            </div>
            
            <div class="singleSpacedDescription">
                <h4>Ctrl-e</h4>
                <p>Go to the end of the command at the current command line.</p>
            </div>
            
			<br/>
			<h3>Multi-line Scripts</h3>
            
			<p>Rename all the files in a particular directory. Specifically, insert the same prefix into each file's name.</p>
<pre class="preCodeWithCaption">
for i in movie_*.txt
do
	mv "$i" "`echo $i | sed 's/movie_//'`"
done
</pre>

            <br/>
			<h3>Tricks with grep</h3>
			<p>grep is great. And powerful. Here are a few ways you can maximize its usefulness.</p>


			<h4>Counting String Instances on a Single Line</h4>
			<p>As everyone knows, it's very easy to use grep for counting the number of times a string appears in a file.</p>
			<p>Suppose you have a file called test.txt which contains one sentence on each line:</p>
<pre class="preCodeWithCaption">
A man is a man.
The man who would hurt a friend is a fiend.
The lady is a tramp.
One small step for man, one giant leap for mankind.
</pre>

			<p>Now suppose you want to find every instance of the string "man" in the file.</p>
<pre class="preCodeWithCaption">
$ grep man test.txt
A man is a man.
The man who would hurt a friend is a fiend.
One small step for man, one giant leap for mankind.
</pre>

			<p>But suppose what you really want is to count the number of times the word "man" occurs.</p>
<pre class="preCodeWithCaption">
$ grep man test.txt | wc -l
3
</pre>

			<p>The problem is obvious: "wc -l" counts the number of lines passed in by the grep, not the number of instances of the word grepped on.</p>

			<p>If all you want is to count the total number of instances in the file, then use grep's "-o" option, which puts each hit on a separate line. Then you can do your line counting.</p>
<pre class="preCodeWithCaption">
$ grep -o man test.txt | wc -l
5
</pre>

			<p>But what if what you really want is to know which lines contain the word "man," and how many instances of the word are on each line? Here's a series of commands that will get you just that.</p>
<pre class="preCodeWithCaption">
$ grep -o -n man test.txt | cut -d : -f 1 | uniq -c
      2 1
      1 2
      2 4
</pre>
			<p>Here's how to read this output. Line 1 contains two instances of the string "man"; line 2 contains 1; and line 4 contains two more.</p>
			<p>We can pretty-up the output a little bit with a few perl one-liners, borrowed from the top of this page.</p>
<pre class="preCodeWithCaption">
$ grep -o -n man test.txt | cut -d : -f 1 | uniq -c | perl -p -e 's/^      /count:/g' | perl -p -e 's/ / line: /g'
count:2 line: 1
count:1 line: 2
count:2 line: 4
</pre>
            <br/>

			<h4>Performing grep on Multiple Patterns</h4>
   			<p>The grep command follows this syntax:</p>
<pre class="preCodeWithCaption">
grep [options] pattern [files]
</pre>
			<p>You see from the syntax that multiple options and multiple files are allowed. Indeed, using multiple options and files are routine. A command of <code>grep -i -v "hi" *.txt</code> would look for all the .txt files where "hi" does NOT occur (-v), no matter what case "hi" is in (-i). ... But what if you want to grep on multiple patterns? The syntax doesn't seem to allow for that.</p>
			<p>egrep, or "grep -e", lets you separate multiple patterns with a pipe. Thus, the following will find all .txt files containing "cat" or "dog".</p>
<pre class="preCodeWithCaption">
$ egrep "cat|dog" *.txt
</pre>
			<p>But if your list is long, or if it's in a file, egrep isn't much help. Fortunately, fgrep (or grep -F) can save the day. There are two ways to use fgrep: (1) by setting an command-line variable to your list of patterns, and then using the variable in your fgrep; or (2) by telling fgrep to read a file for the list of patterns.</p>
			<p>First we'll do it the command-line variable way. Suppose your patterns are "aaa", "bbb", ... "zzz", and you have a list of them in a file, each pattern on a separate line. Select the list and copy it into your clipboard. Then go to the command line and type <code>"patterns="</code> (including the double quotes). Then paste in the patterns from your clipboard. Now run the fgrep command. The entire process looks like this:</p>
<pre class="preCodeWithCaption">
$ patterns="
aaa
bbb
...
zzz"

$ fgrep "${patterns}" *.txt
</pre>

			<p>Now for the other way, which involves invoking the file from fgrep. Put your list of patterns into a file where every pattern is on a separate line. Let's call the file patterns.txt. Then run the following command:</p>
<pre class="preCodeWithCaption">
$ fgrep -F -f patterns.txt *.txt
</pre>

		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
                <div class="title">
                    <h2>Internal Miscellaneous Links</h2>
                </div>
                <ul class="style2">
                    <li><a href="commandLine.html">A Few Command Line Tricks</a></li>
                    <li><a href="macNotes.html">Mac Notes</a></li>
                    <li><a href="svnCommands.html">SVN Command Summary</a></li>
                    <li><a href="svnTasks.html">SVN Tasks</a></li>
                    <li><a href="subversion-cheat-sheet-v1.pdf">SVN Cheat Sheet by AddedBytes.com</a></li>
                </ul>
			</div>
		</div>
	</div>
</div>
<div id="copyright" class="container">
	<p>&copy; 2013-2015 Jerry Kurlandski. All rights reserved. | Original design by <a href="http://www.freecsstemplates.org/" rel="nofollow">FreeCSSTemplates.org</a>.</p>
</div>
</body>
</html>
