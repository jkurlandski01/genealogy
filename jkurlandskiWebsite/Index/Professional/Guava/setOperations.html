<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Sets</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="../../default.css" rel="stylesheet" type="text/css" media="all" />
<link href="../../fonts.css" rel="stylesheet" type="text/css" media="all" />
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->
</head>
<body>
<div id="wrapper">
	<div id="header-wrapper">
		<div id="menu" class="container">
			<ul>
				<li><a href="../index.html">Home</a></li>
				<li class="current_page_item"><a href="../Guava/index.html">Guava</a></li>
				<li><a href="../Java/index.html">Java</a></li>
				<li><a href="../NLP_AI/index.html">NLP / AI</a></li>
				<li><a href="../CSS_HTML/index.html">Int. CSS / HTML</a></li>
				<li><a href="../WWW/index.html">WWW</a></li>
			</ul>
		</div>
		<!-- end #menu -->
		<div id="header" class="container">
			<div id="logo">
				<h1>Close to the</h1>
				<h1>Machine</h1>
				<p></p>
				<p>Jerry Kurlandski</p>
			</div>
			<div id="header-image1"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
			<div id="header-image2"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
		</div>
	</div>
	<div id="page" class="container">
		<div id="content">
			<div class="title">
				<h2>Set Operations in Java on Sets and Lists</h2>
			</div>
			<p>Do an Internet search on "set operations java" and at the top of the results you're sure to find at least one page telling you to use retainAll( ) and addAll( ) for intersection and union, respectively. Some might note that sets and lists behave differently, but generally they don't explore how they behave differently, or what it means to do a traditional set operation on a list. And they certainly don't warn you of the unexpected behavior you'll get if you try to perform a retainAll( ) on a list--let me tell you now that you won't get something akin to set-operation behavior. Here I try to flesh things out a little more deeply.</p>
			
            <h3>Set Operations on Sets</h3>
            <p>This is the easy case, doing set operations on true sets. </p>
            
            <h3>Set Operations on Lists (Multisets)</h3>
            <p>If you are trying to perform set operations on lists, there are three possible explanations, by my count: (1) you don't know what you're doing; (2) you know what you're doing, and you know that your lists are really sets, and you're sure that as the project develops those lists will never one day have duplicate values, which would invalidate them as sets; or (3) you are actually, and knowingly, working with what are called <em>multisets</em>.</p>
            <p>Briefly, a multiset is a set of objects where order does not matter and it is possible to have more than one of each type of element. For example, {a, b, b, c, d} is a multiset, and it is equivalent to {a, c, d, b, b}. Note that the traditional set {a, b, c} is also a multiset, albeit one which has only one element of each type. Another name for multiset is a <em>bag</em>.</p>
            
            <p>We expect set operations to be commutative--that is, we expect A &cap; B = B &cap; A.</p>
            
			<p>"Intersection is done with Collection.retainAll; subtraction with Collection.removeAll; union with Collection.addAll. In each case, as Set will act like a set and a List will act like a list. As mutable objects, they operate in place. You'll need to explicitly copy if you want to retain the original mutable object unmutated."</p>
			
<pre class="preCodeWithCaption">
			    Generalized set operations
The following multiset operations are generalized set operations.
Multiset containment is a Boolean operation, denoted m \in M, which evaluates to true if and only if νM(m) > 0.
Multiset inclusion is a Boolean operation, denoted M \subseteq N, which evaluates to true if and only if \nu_{M}(m) \leq \nu_{N}(m).[5]
Strict multiset inclusion is a Boolean operation, denoted M \subset N, which evaluates to true if and only if νM(m) < νN(m).[6]
The multiset union M \cup N of two multisets M and N is defined as the multiset for which each member m have the maximal multiplicity it has in either multisets[7]
\nu_{M \cup N}(m) := \max(\nu_{M}(m), \nu_{N}(m)).
The multiset intersection M \cap N of two multisets M and N is defined as the multiset for which each member m have the minimal multiplicity it has in either multisets[8]
\nu_{M \cap N}(m) := \min(\nu_{M}(m), \nu_{N}(m)).
</pre>
			<p class="precaption">Listing 1: Using TreeMap to sort the index of an in-memory table</p>
<pre class="preCodeWithCaption">
// JERRY: shouldn't we be using sets, not lists?
                Set<String> canObjectSet = Sets.newHashSet(candDirObjects);
                Set<String> utteranceObjectSet = Sets.newHashSet(utteranceDirObjects);

                // Get the intersection of the two direct object sets.
                if(Sets.intersection(canObjectSet, utteranceObjectSet).isEmpty())     {
                    // Candidate gets a score of 0.
                    LOG.debug("Score = 0.0");
                    continue;
                }

                // Get the intersection of the two direct object sets.
//                List<String> objectIntersection = Lists.newArrayList(candDirObjects);
//                objectIntersection.retainAll(utteranceDirObjects);
//                if(objectIntersection.isEmpty())   {
//                    // Candidate gets a score of 0.
//                    LOG.debug("Score = 0.0");
//                    continue;
//                }
                
                // The user input and the prompt for this candidate share at least one direct object.
                List<String> candIndirObjects = objectsMap.get("indirObjects");
                List<String> utteranceIndirObjects = utteranceObjectsMap.get("indirObjects");
                if(candIndirObjects.isEmpty() || utteranceIndirObjects.isEmpty())   {
                    candidate.setConfidenceScore(0.5);
                    LOG.debug("Score = 0.5");
                    continue;
                }

                Set<String> canIndirObjectSet = Sets.newHashSet(candIndirObjects);
                Set<String> utteranceIndirObjectSet = Sets.newHashSet(utteranceIndirObjects);
                if(Sets.intersection(canIndirObjectSet, utteranceIndirObjectSet).isEmpty()) {
                    // The candidate and the user input share only direct objects.
                    candidate.setConfidenceScore(0.5);
                    LOG.debug("Score = 0.5");
                    continue;
                } else    {
                    // The user input and the prompt for this candidate share both direct objects and indirect objects.
                    candidate.setConfidenceScore(1.0);
                    LOG.debug("Score = 1.0");
                    continue;
                }

//                objectIntersection = Lists.newArrayList(candIndirObjects);
//                objectIntersection.retainAll(utteranceIndirObjects);
//                if(objectIntersection.isEmpty())   {
//                    // They share only direct objects.
//                    candidate.setConfidenceScore(0.5);
//                    LOG.debug("Score = 0.5");
//                    continue;
//                }
//                else    {
//                    // The user input and the prompt for this candidate share both direct objects and indirect objects.
//                    candidate.setConfidenceScore(1.0);
//                    LOG.debug("Score = 1.0");
//                    continue;
//                }
//                
			</pre>

		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
				<div class="title">
					<h2>Internal Guava Links</h2>
				</div>
				<ul class="style2">
					<li><a href="hashBasedTable.html">Using Guava's HashBasedTable class</a></li>
					<li><a href="setOperations.html">Java set operations with Guava</a></li>
				</ul>
			</div>
		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
				<div class="title">
					<h2>External Guava Links</h2>
				</div>
				<ul class="style2">
					<li><a href="http://oeis.org/wiki/Multisets">Multimap Operations</a></li>
				</ul>
			</div>
		</div>
	</div>
</div>
<div id="copyright" class="container">
	<p>Copyright (c) 2013 jkurlandski.com. All rights reserved. | Original design by <a href="http://www.freecsstemplates.org/" rel="nofollow">FreeCSSTemplates.org</a>.</p>
</div>
</body>
</html>
