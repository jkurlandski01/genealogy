http://stackoverflow.com/questions/17572679/java-is-there-any-googles-guava-interface-to-replace-mapstring-mapstring-s
- java. is there any google's guava interface to replace Map<String, Map<String, String>>?

https://code.google.com/p/guava-libraries/wiki/GuavaExplained
- Guava explained
	- There's a "table" section.

HashBasedTable Java doc
http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/HashBasedTable.html

RowBasedTable Java doc
http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/RowSortedTable.html

TreeBasedTable Java doc
http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/TreeBasedTable.html

Explores Guava - Worth reading
http://www.programering.com/a/MzNxUDMwATg.html

To do:
- Separate page on initializing tools, e.g.:
	- Map<Column, String> element = Maps.newHashMap(ImmutableMap.of(Column.TITLE, "Seven Samari", Column.DIRECTOR, "Akira Kurosawa", 
    			Column.COUNTRY, "Japan"));
    - List<String> retList = Lists.newArrayList();
    - Useful especially in method call expecting a list, and you just have one element for the list.
- Incorporate other column data types; actually, make this a separate project
- Get runtime performance of sorted table: I suspect it's O(n)

—————
http://stackoverflow.com/questions/3770289/converting-array-of-primitives-to-array-of-containers-in-java
But then I'd say that Arrays of wrapped primitives are not very useful, so you might want to have a look at Guava instead, which provides Lists of all numeric types, backed by primitive arrays:

List<Integer> intList = Ints.asList(1,2,3,4,5);
List<Long> longList   = Longs.asList(1L,2L,3L,4L,5L);
// etc.
The nice think about these array-backed collections is that

they are live views (i.e. updates to the array change the list and vice-versa)
the wrapper objects are only created when needed (e.g. when iterating the List)
See:

Lists.asList(int ...)
Longs.asList(long ...)
Guava Explained / Primitives


BiMap (mapping keys to values and values back to keys)

Without Guava
	Map<String, Integer> nameToId = Maps.newHashMap();
	Map<Integer, String> idToName = Maps.newHashMap();

	nameToId.put("Bob", 42);
	idToName.put(42, "Bob");
	// what happens if "Bob" or 42 are already present?
	// weird bugs can arise if we forget to keep these in sync...

With Guava
        BiMap<String, Integer> userId = HashBiMap.create();
        userId.put("Bob", 42);

        String userForId = userId.inverse().get(42);
