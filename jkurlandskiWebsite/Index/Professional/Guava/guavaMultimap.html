<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Multimap</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="../../default.css" rel="stylesheet" type="text/css" media="all" />
<link href="../../fonts.css" rel="stylesheet" type="text/css" media="all" />
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->
</head>
<body>
<div id="wrapper">
	<div id="header-wrapper">
		<div id="menu" class="container">
			<ul>
				<li><a href="../index.html">Home</a></li>
				<li class="current_page_item"><a href="../Guava/index.html">Guava</a></li>
				<li><a href="../Java/index.html">Java</a></li>
				<li><a href="../NLP_AI/index.html">NLP / AI</a></li>
				<li><a href="../CSS_HTML/index.html">Int. CSS / HTML</a></li>
				<li><a href="../WWW/index.html">WWW</a></li>
			</ul>
		</div>
		<!-- end #menu -->
		<div id="header" class="container">
			<div id="logo">
				<h1>Close to the</h1>
				<h1>Machine</h1>
				<p></p>
				<p>Jerry Kurlandski</p>
			</div>
			<div id="header-image1"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
			<div id="header-image2"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
		</div>
	</div>
	<div id="page" class="container">
		<div id="content">
			<div class="title">
				<h2>Guava's Multimap</h2>
			</div>
            <p>JERRY: Need links at right.</p>
            <p>JERRY: Work on summary. Call all summaries "Quick View"?</p>
            <p>Guava's Multimap interface and its implementations give Java developers a new tool. It replaces Map&lt;X, List&lt;Y&gt;&gt;, which is a little awkward and sometimes risky. In case you don't know what I'm talking about, see the separate section below on the deficiencies of Map&lt;X, List&lt;Y&gt;&gt;.</p>
            
            <h3>Multimap Summary</h3>
            <p>For those in a hurry, here's a quick view on how to use a multimap.</p>

<p class="precaption">Listing 1: Snapshot on how to use a Multimap</p>
<pre class="preCodeWithCaption">
// Initializing
Multimap&lt;String, String&gt; mm = HashMultimap.create();
Set&lt;String&gt; beList = Sets.newHashSet(&quot;am&quot;, &quot;are&quot;, &quot;is&quot;, &quot;was&quot;, &quot;were&quot;);
mm.putAll(&quot;be&quot;, beList);
mm.put("ask", "ask");
mm.put("ask", "asks");
mm.put("ask", "asked");

// get( )
mm.get("be");
mm.get("ask");

// iterate through all the entries
for(Entry&lt;String, String&gt; mapPair : mm.entries())  {
    String key = mapPair.getKey();
    String value = mapPair.getValue();
}
</pre>

            </br>

            <h3>Multimap Functionality</h3>
            <p>For the sake of illustration, suppose we want to associate a number of simple forms of an English verb with their infinitive form. Before the Multimap, you would probably use a Map&lt;String, Set&lt;String&gt;&gt;, where the key was the infinitive form, and the set associated with each key consisted of all the infinitive's forms. </p>
            <p>With Guava, you would use a Multimap&lt;String, String&gt; instead. The lines below show you how to create the multimap and load it with the forms for two verbs, <em>ask</em> and <em>be</em>.</p>

<p class="precaption">Listing 2: Creating and populating a Multimap</p>
<pre class="preCodeWithCaption">
Multimap&lt;String, String&gt; mm = HashMultimap.create();
mm.put(&quot;ask&quot;, &quot;ask&quot;);
mm.put(&quot;ask&quot;, &quot;asks&quot;);
mm.put(&quot;ask&quot;, &quot;asked&quot;);
Set&lt;String&gt; beList = Sets.newHashSet(&quot;am&quot;, &quot;are&quot;, &quot;is&quot;, &quot;was&quot;, &quot;were&quot;);
mm.putAll(&quot;be&quot;, beList);

// Or allow duplicate values with: Multimap&lt;String, String&gt; mm = ArrayListMultimap.create();
</pre>
        
            <p>Listing 2 shows that you can load each list element individually, with put( ), or collectively, with putAll( ). Significantly, in neither case do you have to worry about whether the key's list has already been instantiated, or whether it already contains some verb forms that you don't want to lose. Also, note the commented-out line at the end, which shows how to instantiate a Multimap that allows repeated values that behave like an ArrayList, rather than values that have HashSet-like behavior.</p>
            <p>Now suppose you've populated your map and you want to do something useful with it.</p>

<p class="precaption">Listing 3: Getting particular Multimap values</p>
<pre class="preCodeWithCaption">
// Getting particular entries.
Set&lt;String&gt; expected = Sets.newHashSet(&quot;am&quot;, &quot;are&quot;, &quot;is&quot;, &quot;was&quot;, &quot;were&quot;);
assertEquals(expected, mm.get(&quot;be&quot;));
assertEquals(0, mm.get(&quot;do&quot;).size());
</pre>

            <p>Listing 3 uses unit tests to show how to get the Multimap values for a given key. First we verify that calling <code>get(&quot;be&quot;)</code> on the multimap we created in the previous listing returns the expected forms of the verb "be." The second assertEquals( ) statement sees how many entries the multimap contains for the key "do." In this case, there are none. Here we see a significant advantage that multimap has over Map&lt;X, List&lt;Y&gt;&gt;, where <code>get(&quot;do&quot;)</code> would return null, and calling size( ) on that would give you nothing but a lousy NullPointerException.</p>

<p class="precaption">Listing 4: Iterating through all Multimap entries</p>
<pre class="preCodeWithCaption">
// Iterate through all the entries
for(Entry&lt;String, String&gt; mapPair : mm.entries())  {
    String key = mapPair.getKey();
    String value = mapPair.getValue();
    System.out.println(&quot;key = &quot; + key + &quot;; value = &quot; + value);
}

Output:
key = ask; value = ask
key = ask; value = asks
key = ask; value = asked
key = be; value = am
key = be; value = are
key = be; value = is
key = be; value = was
key = be; value = were
// Getting particular entries.
assertEquals(beList, mm.get("be"));
assertEquals(0, mm.get("do").size());
</pre>

        <p>The above code snippet shows that, to iterate through a multimap, you don't have to retrieve every key separately, and then iterate through all the elements of its list. The entries( ) method does this work for you.</p>
        
        <p>The next listing shows the multimap's toString( ) override, which allows you to see all the keys and their values without doing any iteration yourself.</p>

<p class="precaption">Listing 5: Multimap's toString( )</p>
<pre class="preCodeWithCaption">
System.out.println("Write using toString():");
System.out.println(mm.toString());

Output:
Write using toString():
{ask=[ask, asks, asked], be=[am, are, is, was, were]}
</pre>

        <p>Perhaps you're completely indifferent about the keys, and all you want is the elements of all the lists. The next example gets all the elements with a method call to values( ); then, just for the fun of it, the code snippet goes on to sort those entries and write out the result.</p>
            
<p class="precaption">Listing 6: Getting just the entries with Multimap.values( )</p>
<pre class="preCodeWithCaption">
// Getting all entries when you don't care about the key.
Collection&lt;String&gt; valuesAsCollection = mm.values();
List&lt;String&gt; valuesAsList = Lists.newArrayList(valuesAsCollection);
Collections.sort(valuesAsList);
System.out.println(valuesAsList);

Output:
[am, are, ask, asked, asks, is, was, were]
</pre>

        <p>Of course, the Multimap interface offers you the same methods you expect from an ordinary map. The next listing demonstrates these with unit test assertions.</p>
            
<p class="precaption">Listing 7: Other useful Multimap methods</p>
<pre class="preCodeWithCaption">
// Testing the values for the key &quot;be&quot;.
// containsKey( )
assertTrue(mm.containsKey(&quot;be&quot;));

// get( )
Collection&lt;String&gt; beForms = mm.get(&quot;be&quot;);
assertEquals(5, beForms.size());

// containsEntry( )
assertTrue(mm.containsEntry(&quot;be&quot;, &quot;was&quot;));

// keySet( )
Set&lt;String&gt; keys = mm.keySet();
assertEquals(2, keys.size());
</pre>

        <p>Finally, the keys( ) method returns another Guava interface called <em>Multiset</em>. The next listing gives you just a taste of what a Multiset can do for you. See the link at right for more.</p>
            
<p class="precaption">Listing 8: Getting a Multiset from Multimap.keys( )</p>
<pre class="preCodeWithCaption">
Multiset&lt;String&gt; multiset = mm.keys();
int size = multiset.size();
assertEquals(8, size);
assertEquals(5, multiset.count(&quot;be&quot;));
assertEquals(3, multiset.count(&quot;ask&quot;));
</pre>
        <br/>

        <h3>The old way, using Map&lt;X, List&lt;Y&gt;&gt;</h3>
        <p>Just in case you're not personally familiar with the problems associated with a Map&lt;X, List&lt;Y&gt;&gt;, let me lay a few on you now.</p>
        <p>The deficiencies of the old way, I think, are most apparent when you haven't loaded the map with its contents yourself, and, consequently, you aren't sure what it contains. The next listing shows the invocation of a method called getHashMap() that returns a Map&lt;String, List&lt;String&gt;&gt;.</p>

<p class="precaption">Listing 9: Adding new values to a Map&lt;String, List&lt;String&gt;&gt; (WARNING: Do not use this code)</p>
<pre class="preCodeWithCaption">
    private Map&lt;String, List&lt;String&gt;&gt; getHashMap() {
        Map&lt;String, List&lt;String&gt;&gt; map = Maps.newHashMap();
        List&lt;String&gt; diveForms = Lists.newArrayList(&quot;dive&quot;, &quot;dives&quot;, &quot;dived&quot;);
        map.put(&quot;dive&quot;, diveForms);
        return map;
    }

    @Test
    public void testOldWay() {
        // Get the map.
        Map&lt;String, List&lt;String&gt;&gt; map = getHashMap();
        
        // Carefully add a new value to the list.
        List&lt;String&gt; diveForms = map.get(&quot;dive&quot;);
        diveForms.add(&quot;dove&quot;);
        // Put not necessary, since we modified a reference. But invoking put( ) will not cause anything to break.
        // map.put(&quot;dive&quot;, diveForms);
        
        // Test passes.
        assertEquals(4, map.get(&quot;dive&quot;).size());
        
        // Oops! Overwriting the old list because you forgot to update the list instead of the map.
        List&lt;String&gt; moreDiveForms = Lists.newArrayList(&quot;diveth&quot;);
        map.put(&quot;dive&quot;, moreDiveForms);
        
        // Test fails.
        assertEquals(5, map.get(&quot;dive&quot;).size());        
    }
    

Test error output:
java.lang.AssertionError: expected:&lt;5&gt; but was:&lt;1&gt;
</pre>
        <p>Let's quickly trace the method testOldWay( ). First it gets the Map&lt;String, List&lt;String&gt;&gt; object. Then it calls get() with the key "dive"; then it adds a new old-fashioned version of the verb into the list. At that point we're done, but a nubie may make the innocuous mistake of putting the modified list into the map. </p>
        <p>All is well so far, but testOldWay( ) goes on to show how a user of the map could unintentionally overwrite existing data. This could happen if he or she is either forgetful or completely unaware that the map may have already been populated for this verb. The user could do this by creating a new list with the new value (in this case the verb form "diveth"), and then putting that into the list. The unit test output catches the problem.</p>
        <p>Achieving the same end with a Multimap is not only slightly less verbose, but also less likely to incur any risks. See below.</p>
<p class="precaption">Listing 10: Adding new values to a Multimap&lt;String, String&gt;</p>
<pre class="preCodeWithCaption">
    private Multimap&lt;String, String&gt; getMultimap() {
        Multimap&lt;String, String&gt; mm = ArrayListMultimap.create();
        List&lt;String&gt; diveForms = Lists.newArrayList(&quot;dive&quot;, &quot;dives&quot;, &quot;dived&quot;);
        mm.putAll(&quot;dive&quot;, diveForms);
        return mm;
    }

    @Test
    public void testNewWay() {
        Multimap&lt;String, String&gt; mm = getMultimap();
        mm.put(&quot;dive&quot;, &quot;dove&quot;);
        
        // Test passes.
        assertEquals(4, mm.get(&quot;dive&quot;).size());
        
        // Add a new value to the list.
        mm.put(&quot;dive&quot;, &quot;diveth&quot;);
        
        // Test passes.
        assertEquals(5, mm.get(&quot;dive&quot;).size());
    }
</pre>


		</div>
		
		<div id="sidebar">
			<div class="internalLinkBox">
				<div class="title">
					<h2>Internal Links</h2>
				</div>
				<ul class="style2">
                    <li><a href="hashBasedTable.html">Using Guava's HashBasedTable class</a></li>
                    <li><a href="setOperations.html">Java set operations with Guava</a></li>
                    <li><a href="guavaMultiset.html">Guava Multiset</a></li>
				</ul>
			</div>
            <div class="internalLinkBox">
                <div class="title">
                    <h2>External Guava Links</h2>
                </div>
                <ul class="style2">
                    <li><a href="http://tomjefferys.blogspot.com/2011/09/multimaps-google-guava.html">How to use Multimaps</a></li>
                    <li><a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/HashBasedTable.html">HashBasedTable Javadoc</a></li>
                </ul>
            </div>
		</div>
	</div>
</div>
<div id="copyright" class="container">
	<p>Copyright (c) 2013 jkurlandski.com. All rights reserved. | Original design by <a href="http://www.freecsstemplates.org/" rel="nofollow">FreeCSSTemplates.org</a>.</p>
</div>
</body>
</html>
