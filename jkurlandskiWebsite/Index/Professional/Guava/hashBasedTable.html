<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Close to the Machine</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="../../default.css" rel="stylesheet" type="text/css" media="all" />
<link href="../../fonts.css" rel="stylesheet" type="text/css" media="all" />
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->
</head>
<body>
<div id="wrapper">
	<div id="header-wrapper">
		<div id="menu" class="container">
			<ul>
				<li><a href="../index.html">Home</a></li>
				<li class="current_page_item"><a href="../Guava/index.html">Guava</a></li>
				<li><a href="../Java/index.html">Java</a></li>
				<li><a href="../NLP_AI/index.html">NLP / AI</a></li>
				<li><a href="../CSS_HTML/index.html">Int. CSS / HTML</a></li>
				<li><a href="../WWW/index.html">WWW</a></li>
			</ul>
		</div>
		<!-- end #menu -->
		<div id="header" class="container">
			<div id="logo">
				<h1>Close to the</h1>
				<h1>Machine</h1>
				<p></p>
				<p>Jerry Kurlandski</p>
			</div>
			<div id="header-image1"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
			<div id="header-image2"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
		</div>
	</div>
	<div id="page" class="container">
		<div id="content">
			<div class="title">
				<div class="noTextTransform">
					<h2>Guava's HashBasedTable and In-Memory Table Structures</h2>
				</div>
			</div>
			<p>More than once I've needed to work with a database table-like structure in memory--a container offering reasonably fast lookups on data having a "row and column" type of structure. Usually what I really want to do is optionally (and efficiently) sort on any of the columns.</p>
			<div class="floatedtable">
				<table border="1">
					<tr>
					<th>Title</th>
					<th>Director</th>
					<th>Country</th>
					</tr>
					<tr>
					<td>Seventh Seal</td>
					<td>Ingmar Bergman</td>
					<td>Sweden</td>
					</tr>
					<tr>
					<td>Seven Samari</td>
					<td>Akira Kurosawa</td>
					<td>Japan</td>
					</tr>
					<tr>
					<td>Seven</td>
					<td>Andy Sidaris</td>
					<td>United States</td>
					</tr>
				</table> 
			    <div class="figcaption">
			        <p>Movie</p>
			    </div>
			</div>
			<p>To make things more concrete, suppose we have an in-memory Movie table like the one at right. Let's say for the sake of argument that the title column is unique, so it can be used as an index into the entire row of values. What I need to do in code is implement this table so that the rows returned can optionally be sorted by title, director or country of origin. Right now they are not sorted at all.</p>
			<h3>Simply sorting on the index</h3>
			<p>JERRY: consider putting this section into a separate page</p>
			<p>It's easy enough to implement the table itself, and to sort your results by the column being used as an index. Simply use a Map&lt;String, List&lt;String&gt;&gt;, where the key is title and the List&lt;String&gt; consists of the two remaining columns for each row, director and country. To sort by title you could: (1) use Java's TreeMap, or (2) get the key set and sort that. If your requirements are as simple as this, here is all you need to do.</p>
			<p class="precaption">Listing 1: Using TreeMap to sort the index of an in-memory table</p>
			<pre><code>
TreeMap<String, Double> map1 = Maps.newTreeMap();
map1.put("one", new Double(1.0));
map1.put("two", new Double(2.0));
map1.put("three", new Double(3.0));
		
// Convert to list for convenience.
List<String> keyList = Lists.newArrayList(map1.keySet());
			</code></pre>

			<p>If you don't need a list of strings, simply iterate through the keys returned by keySet().</p>
			<p>A caution about runtime. Don't be cavalier in your use of TreeMap. Its various operations--get, put, containsKey and remove--are O(log n), which is very good in the sorting sphere but not so good for hashmaps in general. In other words, if you don't need to sort, use the HashMap implementation, whose get and put operations are O(1).</p>
			<p>Notice that it took us four lines to initialize and load the map. Wouldn't it be nice if we could do it more succinctly? As far as I've been able to figure out, you can't with a TreeMap. But with other data structures the Guava libraries offer initializers that let you instantiate and initialize in a single line of code--see the next example below.</p>
			<p class="precaption">Listing 2: Using Arrays.sort() or Collections.sort() to sort the index of an in-memory table</p>
			<pre><code>
Map&lt;String, Double&gt; map2 = Maps.newHashMap(ImmutableMap.of(&quot;one&quot;, new Double(1), &quot;two&quot;, 
    		new Double(2), &quot;three&quot;, new Double(3)));
Set&lt;String&gt; keys = map2.keySet();
String[] keysArray = keys.toArray((new String[keys.size()]));
 
// Don't use both sorts. Use either Arrays.sort() or Collections.sort().
Arrays.sort(keysArray);
List&lt;String&gt; keysList = Arrays.asList(keysArray);
Collections.sort(keysList);
			</code></pre>
			<p>The second example above actually gives you two choices: if you're happy working with a string array, call Arrays.sort() on keysArray; otherwise, convert it to a List of strings and call Collections.sort().</p>
			<p>If your key is a custom value class instead of String, Double, Integer and so on, don't forget to override the necessary methods for safe sorting and the insertion of your class objects into containers. For example, instead of sorting on movie title, maybe you have a Movie class that wraps the movie data into a single object. There are three methods you'll need to override: in the Object class, you'll want to override equals() and hashCode(); and you'll want to declare your class as implementing Comparable and override compareTo(). Chances are you should consider overriding Object.toString() as well. All of this is covered beautifully in Chapter 3 of Joshua Bloch's <em>Effective Java</em>.</p>
			<p>Maybe all you need to do is sort on the index of your in-memory table. In that case, you have my permission to shut down your computer and call it a day. But if your requirements are a little more demanding--that is, if you need to be able to sort on the values in any column--then read on.</p>

			<h3>Introducing Guava's HashBasedTable</h3>
			<p>In the Guava libraries, HashBasedTable implements the Table interface. There are other implementations worth exploring, but the HashBasedTable implementation helps satisfy the sorting requirement outlined at the top of this page, so that is what we focus on here.</p>
			<p>Let's get started by showing you how to create and initialize a HashBasedTable.</p>
			<p class="precaption">Listing 3: Instantiating and initializing a HashBasedTable</p>
			<pre><code>
Table<String, String, String> table = HashBasedTable.create();
table.put("Seventh Seal", "Title", "Seventh Seal");
table.put("Seventh Seal", "Director", "Ingmar Bergman");
table.put("Seventh Seal", "Country", "Sweden");
table.put("Seven Samari", "Title", "Seven Samari");
table.put("Seven Samari", "Director", "Akira Kurosawa");
table.put("Seven Samari", "Country", "Japan");
table.put("Seven", "Title", "Seven");
table.put("Seven", "Director", "Andy Sidaris");
table.put("Seven", "Country", "United States");
			</code></pre>
			<p>Initialization seems quite verbose: you feel as though you should be able to insert into the Table in the same way you insert into a database table--with a single SQL-like insert statement. But when you remember that we're dealing with, at bottom, a hash, it makes perfect sense. Later on we'll see how, with a little abstraction, we can make the HashBasedTable look more like the database table we want to emulate.</p>
			<p>An attentive reader will also note that the second parameter of the put() method is dying for an enum. We'll see that, as well, a little later on.</p>
			<p>Note that I wrote in the paragraph above that the HashBasedTable "helps" satisfy our sorting requirement. It doesn't actually give us the sorting facility. That, we have to implement ourselves. But what it does is give us a view of the table's values for any one column, while retaining a link between the values in that column and the other values in each row. What this means is that, once you have a view on a column, and once you sort on the cells in that column, you have in effect sorted on the entire row.</p>
			<p>Here is some code to illustrate what I mean.</p>
			<p class="precaption">Listing 4: Sorting on the director column</p>
			<pre><code>
// Iterate through all the table cells, getting only those in the Director column.
// O(nbrRows X nbrColumns)
// Elements of table.cellSet() include:
// (Seven Samari,Country)=Japan; (Seven Samari,Title)=Seven Samari; (Seven Samari,Director)=Akira Kurosawa
List&lt;Cell&lt;String, String, String&gt;&gt; filteredList = Lists.newArrayList();
Set&lt;Cell&lt;String, String, String&gt;&gt; cells = table.cellSet();
for(Cell&lt;String, String, String&gt; cell : cells)  {
    if(cell.getColumnKey().equals(&quot;Director&quot;))    {
        filteredList.add(cell);
    }
}
			</code></pre>
			<p>By the time we leave the for loop, which takes O(nbrRows X nrbColumns) time, we have a list that contains the Cell&lt;String, String, String&gt;&#x27;s only for the Director column--that is, for our example, it contains these three elements: [(Seventh Seal,Director)=Ingmar Bergman, (Seven Samari,Director)=Akira Kurosawa, (Seven,Director)=Andy Sidaris]. Once we sort this list on the director's name, we'll have everything we need to return a list of table rows sorted correctly.</p>
			<p>So, how do we sort? We'll let Collections do the work for us, by passing in a Comparator devised just for a Cell<String, String, String> object.</p>
			<p>Here's the one-line call to Collections.sort(), whose runtime is O(nbrRows).</p>
			<p class="precaption">Listing 5: Letting Collections.sort() do the work</p>
			<pre><code>
// Sort the filtered Director cells.
// O(nbrRows)
Collections.sort(filteredList, stringComparator);
			</code></pre>
			<p>Here's the Comparator class. You would need to make this a field accessible to the method that is calling Collections.sort().</p>
			<p class="precaption">Listing 6: The Comparator for the sort</p>
			<pre><code>
public static Ordering&lt;Table.Cell&lt;String, String, String&gt;&gt; stringComparator =
        new Ordering&lt;Table.Cell&lt;String, String, String&gt;&gt;() {
    @Override
    public int compare(
        Table.Cell&lt;String, String, String&gt; cell1, 
        Table.Cell&lt;String, String, String&gt; cell2) {
        String cell1Val = cell1.getValue();
        String cell2Val = cell2.getValue();
        return cell1Val.compareTo(cell2Val);
    }
};
			</code></pre>
			<p>Now filteredList contains each table key paired with its corresponding director, sorted by Director. In other words, for this example it contains these elements in this order: [(Seven Samari,Director)=Akira Kurosawa, (Seven,Director)=Andy Sidaris, (Seventh Seal,Director)=Ingmar Bergman]. But we're missing the Country data. At the cost of iterating through each row one more time--that is, at a cost of O(nbrRows)--we can achieve our goal.</p>
			<p>Here's the way to get the most readable output, as a list of strings.</p>
			<p class="precaption">Listing 5: Letting Collections.sort() do the work</p>
			<pre><code>
			</code></pre>
			<p>And the following listing produces output which would probably be more useful to a programmer, as a List&lt;Map&lt;String, String&gt;&gt;, where the map keys are the column names (i.e., "Title", "Director", and "Country").</p>
			<p class="precaption">Listing 5: Letting Collections.sort() do the work</p>
			<pre><code>
			</code></pre>
			
			<br>
			<p>Note that this structure is not synchronized. See the external links in the sidebar at right for more information.</p>
		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
				<div class="title">
					<h2>Internal Links</h2>
				</div>
				<ul class="style2">
					<li><a href="hashBasedTable.html">Using Guava's HashBasedTable class</a></li>
					<li><a href="setOperations.html">Java set operations with Guava</a></li>
				</ul>
			</div>
		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
				<div class="title">
					<h2>External Guava Links</h2>
				</div>
				<ul class="style2">
					<li><a href="http://tomjefferys.blogspot.com/2011/09/multimaps-google-guava.html">How to use Multimaps</a></li>
					<li><a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/HashBasedTable.html">HashBasedTable Javadoc</a></li>
				</ul>
			</div>
		</div>
	</div>
</div>
<div id="copyright" class="container">
	<p>Copyright (c) 2013 jkurlandski.com. All rights reserved. | Original design by <a href="http://www.freecsstemplates.org/" rel="nofollow">FreeCSSTemplates.org</a>.</p>
</div>
</body>
</html>
