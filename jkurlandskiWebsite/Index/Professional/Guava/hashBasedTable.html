<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Close to the Machine</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="../../default.css" rel="stylesheet" type="text/css" media="all" />
<link href="../../fonts.css" rel="stylesheet" type="text/css" media="all" />
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->
</head>
<body>
<div id="wrapper">
	<div id="header-wrapper">
		<div id="menu" class="container">
			<ul>
				<li><a href="../index.html">Home</a></li>
				<li class="current_page_item"><a href="../Guava/index.html">Guava</a></li>
				<li><a href="../Java/index.html">Java</a></li>
				<li><a href="../NLP_AI/index.html">NLP / AI</a></li>
				<li><a href="../CSS_HTML/index.html">Int. CSS / HTML</a></li>
				<li><a href="../WWW/index.html">WWW</a></li>
			</ul>
		</div>
		<!-- end #menu -->
		<div id="header" class="container">
			<div id="logo">
				<h1>Close to the</h1>
				<h1>Machine</h1>
				<p></p>
				<p>Jerry Kurlandski</p>
			</div>
			<div id="header-image1"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
			<div id="header-image2"> <a href="#" class="image"><img src="../../images/bookshelfPanorama.jpg" alt="" /></a> </div>
		</div>
	</div>
	<div id="page" class="container">
		<div id="content">
			<div class="title">
				<div class="noTextTransform">
					<h2>Guava's HashBasedTable and In-Memory Table Structures</h2>
				</div>
			</div>
			<p>More than a few times I've needed to work with a database table-like structure in memory--a container offering reasonably fast lookups on data having a "row and column" type of structure. Usually what I really want to do is optionally (and efficiently) sort on any of the columns.</p>
			<div class="floatedtable">
				<table border="1">
					<tr>
					<th>Title</th>
					<th>Director</th>
					<th>Country</th>
					</tr>
					<tr>
					<td>Seventh Seal</td>
					<td>Ingmar Bergman</td>
					<td>Sweden</td>
					</tr>
					<tr>
					<td>Seven Samari</td>
					<td>Akira Kurosawa</td>
					<td>Japan</td>
					</tr>
					<tr>
					<td>Seven</td>
					<td>Andy Sidaris</td>
					<td>United States</td>
					</tr>
				</table> 
			    <div class="figcaption">
			        <p>Movie</p>
			    </div>
			</div>
			<p>To make things more concrete, suppose we have an in-memory Movie table like the one at right. Let's say for the sake of argument that the title column is unique, so it can be used as an index into the entire row of values. What I need to do in code is implement this table so that the rows returned can optionally be sorted by title, director or country of origin. Right now they are not sorted at all.</p>
			<h3>Simply sorting on the index</h3>
			<p>JERRY: redo the listing numbers below after removing snippets; use preCodeWithOptions</p>
			<p>In just about any programming language, it's easy to implement a table-like structure with a map. For the table given above, you would simply use a Map&lt;String, List&lt;String&gt;&gt;, where the key is title and the List&lt;String&gt; consists of the two remaining columns for each row, director and country. And it's not much harder to allow some sorting by column values--if all you need to sort on is the column represented by the key of the map. To sort by title you could: (1) use Java's TreeMap, or (2) get the key set and sort that. See the link to the right for details.</p>

			<p>Maybe all you need to do is sort on the key of your in-memory table. But if your requirements are a little more demanding--that is, if you need to be able to sort on the values in any column--then read on.</p>

			<h3>Introducing Guava's HashBasedTable</h3>
			<p>In the Guava libraries, HashBasedTable implements the Table interface. There are other implementations worth exploring, but the HashBasedTable implementation helps satisfy the sorting requirement outlined at the top of this page, so that is what we focus on here.</p>
			<p>Let's get started by showing you how to create and initialize a HashBasedTable.</p>
			<p class="precaption">Listing 3: Instantiating and initializing a HashBasedTable</p>
            <pre class="withCaption">
Table&lt;String, String, String&gt; table = HashBasedTable.create();
table.put(&quot;Seventh Seal&quot;, &quot;Title&quot;, &quot;Seventh Seal&quot;);
table.put(&quot;Seventh Seal&quot;, &quot;Director&quot;, &quot;Ingmar Bergman&quot;);
table.put(&quot;Seventh Seal&quot;, &quot;Country&quot;, &quot;Sweden&quot;);
table.put(&quot;Seven Samari&quot;, &quot;Title&quot;, &quot;Seven Samari&quot;);
table.put(&quot;Seven Samari&quot;, &quot;Director&quot;, &quot;Akira Kurosawa&quot;);
table.put(&quot;Seven Samari&quot;, &quot;Country&quot;, &quot;Japan&quot;);
table.put(&quot;Seven&quot;, &quot;Title&quot;, &quot;Seven&quot;);
table.put(&quot;Seven&quot;, &quot;Director&quot;, &quot;Andy Sidaris&quot;);
table.put(&quot;Seven&quot;, &quot;Country&quot;, &quot;United States&quot;);
			</pre>
			<p>Initialization seems quite verbose: you feel as though you should be able to insert into the Table in the same way you insert into a database table--with a single SQL-like insert statement. But when you remember that we're dealing with, at bottom, a hash, it makes perfect sense. Later on we'll see how, with a little abstraction, we can make the HashBasedTable look more like the database table we want to emulate.</p>
			<p>An attentive reader will also note that the second parameter of the put() method is dying for an enum. We'll see that, as well, a little later on.</p>
			<p>Note that I wrote in the paragraph above that the HashBasedTable "helps" satisfy our sorting requirement. It doesn't actually give us the sorting facility. That, we have to implement ourselves. But what it does is give us a view of the table's values for any one column, while retaining a link between the values in that column and the other values in each row. What this means is that, once you have a view on a column, and once you sort on the cells in that column, you have in effect sorted on the entire row.</p>
			<p>Here is some code to illustrate what I mean.</p>
			<p class="precaption">Listing 4: Sorting on the director column</p>
            <pre class="withCaption">
// Iterate through all the table cells, getting only those in the Director column.
// O(nbrRows X nbrColumns)
// Elements of table.cellSet() include:
// (Seven Samari,Country)=Japan; (Seven Samari,Title)=Seven Samari; (Seven Samari,Director)=Akira Kurosawa
List&lt;Cell&lt;String, String, String&gt;&gt; filteredList = Lists.newArrayList();
Set&lt;Cell&lt;String, String, String&gt;&gt; cells = table.cellSet();
for(Cell&lt;String, String, String&gt; cell : cells)  {
    if(cell.getColumnKey().equals(&quot;Director&quot;))    {
        filteredList.add(cell);
    }
}
			</pre>
			<p>By the time we leave the for loop, which takes O(nbrRows X nrbColumns) time, we have a list that contains the Cell&lt;String, String, String&gt;&#x27;s only for the Director column--that is, for our example, it contains these three elements: [(Seventh Seal,Director)=Ingmar Bergman, (Seven Samari,Director)=Akira Kurosawa, (Seven,Director)=Andy Sidaris]. Once we sort this list on the director's name, we'll have everything we need to return a list of table rows sorted correctly.</p>
			<p>So, how do we sort? We'll let Collections do the work for us, by passing in a Comparator devised just for a Cell<String, String, String> object.</p>
			<p>Here's the one-line call to Collections.sort(), whose runtime is O(nbrRows).</p>
			<p class="precaption">Listing 5: Letting Collections.sort() do the work</p>
            <pre class="withCaption">
// Sort the filtered Director cells.
// O(nbrRows)
Collections.sort(filteredList, stringComparator);
			</pre>
			<p>Here's the Comparator class. You would need to make this a field accessible to the method that is calling Collections.sort().</p>
			<p class="precaption">Listing 6: The Comparator for the sort</p>
            <pre class="withCaption">
public static Ordering&lt;Table.Cell&lt;String, String, String&gt;&gt; stringComparator =
        new Ordering&lt;Table.Cell&lt;String, String, String&gt;&gt;() {
    @Override
    public int compare(
        Table.Cell&lt;String, String, String&gt; cell1, 
        Table.Cell&lt;String, String, String&gt; cell2) {
        String cell1Val = cell1.getValue();
        String cell2Val = cell2.getValue();
        return cell1Val.compareTo(cell2Val);
    }
};
			</pre>
			<p>Now filteredList contains each table key paired with its corresponding director, sorted by Director. In other words, for this example it contains these elements in this order: [(Seven Samari,Director)=Akira Kurosawa, (Seven,Director)=Andy Sidaris, (Seventh Seal,Director)=Ingmar Bergman]. But we're missing the Country data. At the cost of iterating through each row one more time--that is, at a cost of O(nbrRows)--we can achieve our goal.</p>
			<p>Here's the way to get the most readable output, as a list of strings.</p>
			<p class="precaption">Listing 7: Putting the sorted data into a string</p>
            <pre class="withCaption">
// Put the data into a list of strings.
// O(nbrRows)
List&lt;String&gt; rowList = Lists.newArrayList();
for(Cell&lt;String, String, String&gt; cell : filteredList)   {
    Map&lt;String, String&gt; row = table.row(cell.getRowKey());
    StringBuilder builder = new StringBuilder();
    builder.append(row.get(&quot;Title&quot;)).append(&quot;; &quot;)
        .append(row.get(&quot;Director&quot;)).append(&quot;; &quot;)
        .append(row.get(&quot;Country&quot;)).append(&quot;\n&quot;);
    rowList.add(builder.toString());
}
System.out.println(rowList.toString());

Output:
[Seven Samari; Akira Kurosawa; Japan
, Seven; Andy Sidaris; United States
, Seventh Seal; Ingmar Bergman; Sweden
]
			</pre>
			<p>So the variable rowList above contains three elements, one for each movie. The first line reads: "Seven Samari; Akira Kurosawa; Japan".</p>
			<p>And the following listing produces output which would probably be more useful to a programmer, as a List&lt;Map&lt;String, String&gt;&gt;, where the map keys are the column names (i.e., "Title", "Director", and "Country").</p>
			<p class="precaption">Listing 8: Putting the sorted data into a map</p>
            <pre class="withCaption">
// Put the data into a List of Map&lt;String, String&gt; where key is column name.
// O(nbrRows)
List&lt;Map&lt;String, String&gt;&gt; rowMapList = Lists.newArrayList();
for(Cell&lt;String, String, String&gt; cell : filteredList)   {
    Map&lt;String, String&gt; row = table.row(cell.getRowKey());
    rowMapList.add(row);
}
System.out.println(rowMapList.toString());

Output:
[{Country=Japan, Title=Seven Samari, Director=Akira Kurosawa}, {Country=United States, Title=Seven, Director=Andy Sidaris}, {Country=Sweden, Title=Seventh Seal, Director=Ingmar Bergman}]
			</pre>
			<p>The list produced by the snippet above contains three elements, one for each row of our table structure. The first row gives us the data on Kurosawa's "Seven Samari" in the form of a Map&lt;String, String&gt. Each row's map contains three keys: "Title", "Director" and "Country."</p>
			<p>This is all well and good, but it would be a pain to write specialized code every time you need a table structure that can be sorted by any column. Why not encaspulate and abstract this behavior into a useful class? That's what we'll do next.</p>
			<p><a href="sortableTable.html">A Sortable Table Class</a></p>
			<p>JERRY: Then a descriptive link to another page. New page summarizes where we are with link to previous. Then new page lists the ways in which the previous page's implementation is lacking: 1) needs to be encapsulated; 2) needs to be abstracted; 3) needs an enum instead of column name; 4) needs to deal with numeric sorting.</p>
			
			<br>
			<p>Note that this structure is not synchronized. See the external links in the sidebar at right for more information.</p>
			<p>JERRY: add links</p>
		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
				<div class="title">
					<h2>Internal Links</h2>
				</div>
				<ul class="style2">
					<li><a href="hashBasedTable.html">Using Guava's HashBasedTable class</a></li>
					<li><a href="setOperations.html">Java set operations with Guava</a></li>
				</ul>
			</div>
		</div>
		<div id="sidebar">
			<div class="internalLinkBox">
				<div class="title">
					<h2>External Guava Links</h2>
				</div>
				<ul class="style2">
					<li><a href="http://tomjefferys.blogspot.com/2011/09/multimaps-google-guava.html">How to use Multimaps</a></li>
					<li><a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/HashBasedTable.html">HashBasedTable Javadoc</a></li>
				</ul>
			</div>
		</div>
	</div>
</div>
<div id="copyright" class="container">
	<p>Copyright (c) 2013 jkurlandski.com. All rights reserved. | Original design by <a href="http://www.freecsstemplates.org/" rel="nofollow">FreeCSSTemplates.org</a>.</p>
</div>
</body>
</html>
